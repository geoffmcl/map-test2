<!doctype html>
<html lang=en>
<head>
<title>Display CSV</title>
<meta charset=utf-8>
  <meta name="author"
        content="Geoff, inspired by Theo">
</head>
<body>
<script src = http://mrdoob.github.io/three.js/build/three.min.js ></script>
<script src = http://mrdoob.github.io/three.js/examples/js/controls/TrackballControls.js ></script>
<script src = http://mrdoob.github.io/three.js/examples/js/libs/stats.min.js ></script>
<script>
/*\
 *  CSV header lines
 *  icao,"name",lat,lon,runways,ils,elev_ft_AMSL [apt1000-heli.csv]
 *  icao,"name",lat,lon,runways,ils,elev_ft_AMSL [apt1000-icao.csv]
 *  icao,"name",lat,lon,runways,ils,elev_ft_AMSL [apt1000-ils.csv]
 *  type,lat,lon,feet,freq,rng,bear,id,icao,rwy,"name" [apt1000-nav.csv]
 *  icao,"name",lat,lon,runways,ils,elev_ft_AMSL [apt1000-sea.csv]
 *  type,lat,lon,feet,freq,rng,bear,id,name [clean-nav.csv]
 *  Name,BgnInt,blat,blon,EndInt,elat,elon,HL,Base,Top [xp-awy.csv]
 *  latitude,longitude,name [xp-fixes.csv]
\*/

	var pi = Math.PI;
	var d2r = pi / 180;

	var camera, scene, renderer, stats;
	var start = new Date();

    //            0                  1                  2                 3                 4                 5                6            7
	var files = ['apt1000-heli.csv','apt1000-icao.csv','apt1000-ils.csv','apt1000-nav.csv','apt1000-sea.csv','clean-nav.csv','xp-awy.csv','xp-fixes.csv'];
    
	init();
	animate();
    
	function init() {
		
		stats = new Stats();
		stats.domElement.style.cssText = 'position: absolute; right: 0; top: 0; zIndex: 100; ';
		document.body.appendChild( stats.domElement );

		renderer = new THREE.WebGLRenderer( { alpha: 1, antialias: true, clearColor: 0xffffff }  );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.set( 1000, 1000, 1000 );
		controls = new THREE.TrackballControls( camera, renderer.domElement );

        // geoffmcl.github.io/map-test2/tree/gh-pages/data2/apt1000-ils.csv
        var file;
        var sep = ',';
        len = files.length;
		for (i = 0; i < len; i++) {
            file = 'data2/'+files[i];
			requestFileCB( file, CB_handler );
        }
    }
    
    var cb_count = 0;
    var next_icao = 0;
    var next_type = 0;
    function CB_handler() {
        if ((this.readyState == 4) && (this.status == "200")) {
            var ind = 7;
            var text = this.responseText;
            cb_count++;
            var lines = text.split(/\r\n|\n/);
            var length = lines.length - 1;
            var i,j,line,lat,lon;
            var data = [];
            var sep = ',';
            line = lines[0].split( sep );
            if (line[0] == 'latitude') {
                ind = 7;
            } else if (line[0] == 'icao') {
                if (next_icao == 0) {
                    ind = 0;  // heli
                } else if (next_icao == 1) {
                    ind = 1;  // icao
                } else if (next_icao == 2) {
                    ind = 2;  // ils
                } else { // if (next_icao == 3) {
                    ind = 4;  // sea
                } 
                next_icao++;
            } else if (line[0] == 'type') {
                if (next_type == 0) {
                    ind = 3;  // nav
                } else {
                    ind = 5;  // clean
                }
                next_type++;
            } else if (line[0] == 'Name') {
                ind = 6;    // 
            }
            i = ind;
            var file = files[i];
            for ( j = 1; j < length; j++ ) {
                line = lines[j].split( sep );
                if ( i === 7 ) {
                    lat = parseFloat(line[0]);
                    lon = parseFloat(line[1]);
                } else if ( i === 3 || i === 5) {
                    lat = parseFloat(line[1]);
                    lon = parseFloat(line[2]);
                } else {
                    lat = parseFloat(line[2]);
                    lon = parseFloat(line[3]);
                }
                data.push( [lat,lon,i] );
            }

            var particles = data.length;
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', Float32Array, particles, 3 );
            geometry.addAttribute( 'color', Float32Array, particles, 3 );

            var positions = geometry.attributes.position.array;
            var colors = geometry.attributes.color.array;

            //var color = new THREE.Color();
            var color, cname;
            if ((ind == 0)||(ind == 3)||(ind == 6)) {
                color = new THREE.Color(0xFF0000);
                cname = 'red';
            } else if ((ind == 1)||(ind == 4)||(ind == 7)) {
                color = new THREE.Color(0x00FF00);
                cname = 'green';
            } else {
                color = new THREE.Color(0x0000FF);
                cname = 'blue';
            }
            var n = 1000, n2 = n / 2; // particles spread in the cube
            var p, pt;
                //var vx = ( x / n ) + 0.5;
                //var vy = ( y / n ) + 0.5;
                //var vz = ( z / n ) + 0.5;

                //color.setRGB( vx, vy, vz );
            
            j = 0;
            len = positions.length;
            for ( i = 0; i < len; i += 3 ) {
                p = data[j++];
                pt = convertPosition( parseFloat( p[0]), parseFloat( p[1] ), p[2] * 100 )
                var x = pt.x;
                var y = pt.y;
                var z = pt.z;

                positions[ i ]     = x;
                positions[ i + 1 ] = y;
                positions[ i + 2 ] = z;

                //var vx = ( x / n ) + 0.5;
                //var vy = ( y / n ) + 0.5;
                //var vz = ( z / n ) + 0.5;

                //color.setRGB( vx, vy, vz );

                colors[ i ]     = color.r;
                colors[ i + 1 ] = color.g;
                colors[ i + 2 ] = color.b;
            }

            geometry.computeBoundingSphere();
            var material = new THREE.ParticleSystemMaterial( { size: 10, vertexColors: true } );
            var particleSystem = new THREE.ParticleSystem( geometry, material );
            scene.add( particleSystem );

            console.log( 'Loaded '+file+' ind='+ind+' color '+cname+' Elapsed '+ getElapsed(start) );
        } 
	}

	function convertPosition( lat, lon, radius ) {
		var rc = radius * Math.cos( lat * d2r );
		return new THREE.Vector3( rc * Math.cos( lon * d2r ), radius * Math.sin( lat * d2r ), rc * Math.sin( lon * d2r) );
	}

	function animate() {
		requestAnimationFrame( animate );
		controls.update();
		renderer.render( scene, camera );
		stats.update();
	}

	function requestFile( fname ) {
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.crossOrigin = "Anonymous"; 
		xmlHttp.open( 'GET', fname, false );
		xmlHttp.send( null );
		return xmlHttp.responseText;
	}
    
	// function requestFileCB( fname, callback, func ) {
	function requestFileCB( fname, callback ) {
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.open( 'GET', fname, true );
        xmlHttp.onreadystatechange = callback;
        //xmlHttp.onloadend = func;
		xmlHttp.send( null );
	}

    function getElapsed(bgn) {
        var d = new Date();
        var ms = d.valueOf() - bgn.valueOf();
        var elap = ms2hhmmss(ms);
        return elap;
    }
    
    function ms2hhmmss( ms ) {
        if (ms < 1000) {
            return ''+ms+' ms';
        }
        var secs = Math.floor( ms / 1000 );
        ms -= (secs * 1000);
        if (secs < 60) {
            var stg = ''+((ms / 1000).toFixed(2));
            stg = stg.substr(1);    // drop the zero
            return ''+secs+stg+' secs';
        }
        var mins = Math.floor(secs / 60);
        secs -= (mins * 60);
        if (ms > 500)
            secs++;
        if (secs >= 60) {
            secs -= 60;
            mins++;
        }
        if (mins < 60) {
            if (secs < 10)
                secs = '0'+secs;
            return ''+mins+':'+secs+' mm:ss';
        }
        var hours = Math.floor(mins / 60);
        mins -= (hours * 60);
        if (mins < 10)
            mins = '0'+mins;
        if (secs < 10)
            secs = '0'+secs;
        return ''+hours+':'+mins+':'+secs+' hh:mm:ss';
    }
    
</script>
</body>
</html>